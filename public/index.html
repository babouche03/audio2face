<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio2Face 3D Avatar</title>
    <!-- Three.js via CDN -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
        }
    }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            max-width: 400px;
            backdrop-filter: blur(10px);
        }

        h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 24px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 600;
            font-size: 14px;
        }

        input[type="text"],
        input[type="file"],
        select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s;
        }

        input[type="text"]:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-bottom: 10px;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        button.secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        #status {
            margin-top: 15px;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            display: none;
        }

        #status.info {
            background: #e3f2fd;
            color: #1976d2;
            display: block;
        }

        #status.error {
            background: #ffebee;
            color: #c62828;
            display: block;
        }

        #status.success {
            background: #e8f5e9;
            color: #2e7d32;
            display: block;
        }

        .info-text {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
        }

        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-right: 8px;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .toggle-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .toggle-btn {
            flex: 1;
            padding: 10px;
            background: #f0f0f0;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            font-weight: 600;
            transition: all 0.3s;
        }

        .toggle-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>
        <div id="controls" style="margin-top: 3rem;">
            <h2>ğŸ­ Audio2Face 3D</h2>
            
            <div class="toggle-group">
                <div class="toggle-btn active" onclick="switchMode('test')">æµ‹è¯•æ¨¡å¼</div>
                <div class="toggle-btn" onclick="switchMode('api')">API æ¨¡å¼</div>
            </div>

            <div class="form-group">
                <label>é€‰æ‹©æ¨¡å‹</label>
                <select id="modelSelect">
                    <option value="claire">Claire</option>
                    <option value="mark">Mark</option>
                    <option value="james">James</option>
                </select>
            </div>

            <div class="form-group" id="apiKeyGroup" style="display: none;">
                <label>API Key</label>
                <input type="text" id="apiKey" placeholder="nvapi-xxx...">
                <div class="info-text">ä» NVIDIA API Catalog è·å–</div>
            </div>

            <div class="form-group">
                <label>ä¸Šä¼ éŸ³é¢‘ (WAV/MP3)</label>
                <input type="file" id="audioFile" accept="audio/*">
            </div>

            <button id="startBtn" onclick="startAnimation()">
                å¼€å§‹ç”ŸæˆåŠ¨ç”»
            </button>

            <div id="status"></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // é…ç½®
        const API_BASE_URL = 'http://localhost:3000';
        let currentMode = 'test'; // 'test' æˆ– 'api'

        // Three.js åœºæ™¯è®¾ç½®
        let scene, camera, renderer, head;
        let blendShapeTargets = {};
        let currentAnimation = null;
        let audioElement = null;

        // åˆå§‹åŒ– Three.js åœºæ™¯
        function initScene() {
            //åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            //é•œå¤´
            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 8;
            camera.position.y = 2.2;
            camera.position.x = -2;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // æ·»åŠ å…‰æº
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0xffffff, 0.5);
            pointLight.position.set(-5, 5, 5);
            scene.add(pointLight);

            // åˆ›å»º3Då¤´åƒæ¨¡å‹
            createHead();

            // çª—å£è°ƒæ•´
            window.addEventListener('resize', onWindowResize);
            
            animate();
        }

        function createHead() {
            const modelSelect = document.getElementById('modelSelect');
            const selectedModel = modelSelect.value;

            // ä»æœåŠ¡å™¨ API è·å–æ¨¡å‹é…ç½®
            fetch(`${API_BASE_URL}/api/model-config/${selectedModel}`)
                .then(response => response.json())
                .then(result => {
                    if (!result.success) {
                        throw new Error(result.error || 'è·å–æ¨¡å‹é…ç½®å¤±è´¥');
                    }
                    const blendshapeId = result.data.blendshape_id;
                    const modelPath = `/models/${blendshapeId}.glb`;
                    console.log(`å°è¯•åŠ è½½æ¨¡å‹æ–‡ä»¶: ${modelPath}`);
                    console.log(result);

                    // å…ˆæ£€æŸ¥æ¨¡å‹æ–‡ä»¶æ˜¯å¦å­˜åœ¨
                    fetch(modelPath, { method: 'HEAD' })
                        .then(response => {
                            if (!response.ok) {
                                // æä¾›æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
                                const errorMsg = `3D æ¨¡å‹æ–‡ä»¶ä¸å­˜åœ¨: ${blendshapeId}.glb\n\n` +
                                    `è¯´æ˜ï¼šYAML é…ç½®æ–‡ä»¶ï¼ˆconfig_claire.yml ç­‰ï¼‰åªæ˜¯é…ç½®æ–‡ä»¶ï¼Œä¸æ˜¯ 3D æ¨¡å‹æ–‡ä»¶ã€‚\n` +
                                    `æ‚¨éœ€è¦å°†å®é™…çš„ .glb æ ¼å¼çš„ 3D æ¨¡å‹æ–‡ä»¶æ”¾ç½®åœ¨é¡¹ç›®çš„ models ç›®å½•ä¸­ã€‚\n\n` +
                                    `éœ€è¦çš„æ–‡ä»¶: ${blendshapeId}.glb\n` +
                                    `æ–‡ä»¶ä½ç½®: ./models/${blendshapeId}.glb\n\n` +
                                    `è¿™äº›æ¨¡å‹æ–‡ä»¶é€šå¸¸éœ€è¦ä» NVIDIA Audio2Face æˆ–ç›¸å…³èµ„æºè·å–ã€‚`;
                                throw new Error(errorMsg);
                            }
                            
                            const loader = new GLTFLoader();
                            loader.load(modelPath, (gltf) => {
                                if (head) {
                                    scene.remove(head); // ç§»é™¤å½“å‰æ¨¡å‹
                                }
                                head = gltf.scene;
                                head.scale.set(2.0, 2.0, 2.0); // è°ƒæ•´æ¨¡å‹å¤§å°
                                scene.add(head);
                                
                                // åˆå§‹åŒ– userDataï¼Œç”¨äºå­˜å‚¨åŠ¨ç”»æ§åˆ¶å¯¹è±¡
                                initializeHeadUserData(head);
                                
                                showStatus(`æ¨¡å‹ ${blendshapeId} åŠ è½½æˆåŠŸ`, 'success');
                            }, undefined, (error) => {
                                console.error('åŠ è½½æ¨¡å‹å¤±è´¥:', error);
                                showStatus('åŠ è½½æ¨¡å‹å¤±è´¥: ' + error.message, 'error');
                                // åˆ›å»ºå ä½å‡ ä½•ä½“
                                createPlaceholderHead();
                            });
                        })
                        .catch(error => {
                            console.error('æ¨¡å‹æ–‡ä»¶æ£€æŸ¥å¤±è´¥:', error);
                            showStatus(error.message, 'error');
                            // åˆ›å»ºå ä½å‡ ä½•ä½“
                            createPlaceholderHead();
                        });
                })
                .catch(error => {
                    console.error('è·å–æ¨¡å‹é…ç½®å¤±è´¥:', error);
                    showStatus('è·å–æ¨¡å‹é…ç½®å¤±è´¥: ' + error.message, 'error');
                });
        }

        document.getElementById('modelSelect').addEventListener('change', createHead);

        // åˆ›å»ºå ä½å‡ ä½•ä½“ï¼ˆå½“æ¨¡å‹æ–‡ä»¶ä¸å­˜åœ¨æ—¶ï¼‰
        function createPlaceholderHead() {
            if (head) {
                scene.remove(head);
            }
            
            // åˆ›å»ºä¸€ä¸ªç®€å•çš„å¤´éƒ¨å ä½å‡ ä½•ä½“
            const geometry = new THREE.SphereGeometry(1, 32, 32);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0xffdbac,
                transparent: true,
                opacity: 0.8
            });
            head = new THREE.Mesh(geometry, material);
            head.scale.set(1.5, 1.5, 1.5);
            scene.add(head);
            
            // æ·»åŠ çœ¼ç›
            const eyeGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.3, 0.2, 0.8);
            head.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.3, 0.2, 0.8);
            head.add(rightEye);
            
            // æ·»åŠ å˜´å·´
            const mouthGeometry = new THREE.TorusGeometry(0.15, 0.05, 8, 16);
            const mouthMaterial = new THREE.MeshPhongMaterial({ color: 0x8b0000 });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, -0.3, 0.8);
            mouth.rotation.x = Math.PI / 2;
            head.add(mouth);
            
            // åˆå§‹åŒ– userData
            initializeHeadUserData(head);
            
            console.log('å·²åˆ›å»ºå ä½å‡ ä½•ä½“ï¼ˆæ¨¡å‹æ–‡ä»¶ä¸å­˜åœ¨ï¼‰');
        }

        //head.userdata.mouth, leftEye, rightEye, leftBrow, rightBrow
        // åˆå§‹åŒ– head.userDataï¼Œç”¨äºå­˜å‚¨åŠ¨ç”»æ§åˆ¶å¯¹è±¡
        function initializeHeadUserData(headObj) {
            if (!headObj.userData) {
                headObj.userData = {};
            }
            
            // å°è¯•ä»æ¨¡å‹ä¸­æŸ¥æ‰¾è¿™äº›å¯¹è±¡ï¼Œå¦‚æœæ‰¾ä¸åˆ°åˆ™åˆ›å»ºå ä½å¯¹è±¡
            const findChildByName = (parent, name) => {
                // console.log(`æ­£åœ¨æŸ¥æ‰¾å¯¹è±¡: ${name} åœ¨çˆ¶å¯¹è±¡: ${parent.name || 'unnamed'}`);
                if (parent.name && parent.name.toLowerCase().includes(name.toLowerCase())) {
                    console.log(`æ‰¾åˆ°å¯¹è±¡: ${parent.name} å¯¹åº” ${name}`);
                    return parent;
                }
                for (let child of parent.children) {
                    const found = findChildByName(child, name);
                    if (found) return found;
                }
                return null;
            };
            
            // æŸ¥æ‰¾æˆ–åˆ›å»ºå˜´å·´å¯¹è±¡
            headObj.userData.mouth = findChildByName(headObj, 'mouth') || 
                findChildByName(headObj, 'jaw') || 
                headObj.children.find(child => child.name && child.name.includes('Mouth')) ||
                headObj; // å¦‚æœæ‰¾ä¸åˆ°ï¼Œä½¿ç”¨ head æœ¬èº«
            
            // æŸ¥æ‰¾æˆ–åˆ›å»ºçœ¼ç›å¯¹è±¡
            headObj.userData.leftEye = findChildByName(headObj, 'lefteye') || 
                findChildByName(headObj, 'eyeleft') ||
                headObj.children.find(child => child.name && (child.name.includes('LeftEye') || child.name.includes('EyeL'))) ||
                headObj;
            
            headObj.userData.rightEye = findChildByName(headObj, 'righteye') || 
                findChildByName(headObj, 'eyeright') ||
                headObj.children.find(child => child.name && (child.name.includes('RightEye') || child.name.includes('EyeR'))) ||
                headObj;
            
            // æŸ¥æ‰¾æˆ–åˆ›å»ºçœ‰æ¯›å¯¹è±¡
            headObj.userData.leftBrow = findChildByName(headObj, 'leftbrow') || 
                findChildByName(headObj, 'browleft') ||
                headObj.children.find(child => child.name && child.name.includes('BrowL')) ||
                headObj;
            
            headObj.userData.rightBrow = findChildByName(headObj, 'rightbrow') || 
                findChildByName(headObj, 'browright') ||
                headObj.children.find(child => child.name && child.name.includes('BrowR')) ||
                headObj;
                
            console.log('Head userData åˆå§‹åŒ–å®Œæˆ:', headObj.userData);
        }

        function animate() {
            requestAnimationFrame(animate);

            // åŸºç¡€å±•ç¤ºåŠ¨ç”»
            // if (head && !currentAnimation) {
            //     head.rotation.y += 0.002;                
            // }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // åˆ‡æ¢æ¨¡å¼
        window.switchMode = function switchMode(mode) {
            currentMode = mode;

            const btns = document.querySelectorAll('.toggle-btn');
            btns.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            const apiKeyGroup = document.getElementById('apiKeyGroup');
            apiKeyGroup.style.display = mode === 'api' ? 'block' : 'none';
        };

        // çŠ¶æ€æ˜¾ç¤ºå‡½æ•°
        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = type;
        }

        // ä¸»å‡½æ•°:å¼€å§‹åŠ¨ç”»ç”Ÿæˆ
        window.startAnimation = async function startAnimation() {
            const audioFile = document.getElementById('audioFile').files[0];
            const selectedModel = document.getElementById('modelSelect').value; // è·å–ç”¨æˆ·é€‰æ‹©çš„æ¨¡å‹
            const apiKey = document.getElementById('apiKey').value.trim();
            const startBtn = document.getElementById('startBtn');

            if (!audioFile) {
                showStatus('è¯·ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶', 'error');
                return;
            }

            if (currentMode === 'api' && !apiKey) {
                showStatus('API æ¨¡å¼éœ€è¦è¾“å…¥ API Key', 'error');
                return;
            }

            startBtn.disabled = true;
            startBtn.innerHTML = '<span class="loading"></span>å¤„ç†ä¸­...';
            showStatus('æ­£åœ¨å¤„ç†éŸ³é¢‘...', 'info');

            try {
                const formData = new FormData();
                formData.append('audio', audioFile);
                formData.append('model', selectedModel); // å°†ç”¨æˆ·é€‰æ‹©çš„æ¨¡å‹å‘é€åˆ°åç«¯
                if (currentMode === 'api') {
                    formData.append('apiKey', apiKey);
                }

                const endpoint = currentMode === 'test'
                    ? `${API_BASE_URL}/api/test-animation`
                    : `${API_BASE_URL}/api/generate-animation`;

                showStatus('æ­£åœ¨è°ƒç”¨åç«¯æœåŠ¡...', 'info');

                const response = await fetch(endpoint, {
                    method: 'POST',
                    body: formData,
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message || 'æœåŠ¡å™¨é”™è¯¯');
                }

                const result = await response.json();

                if (!result.success) {
                    throw new Error(result.error || 'å¤„ç†å¤±è´¥');
                }

                showStatus('åŠ¨ç”»æ•°æ®æ¥æ”¶æˆåŠŸ,å¼€å§‹æ’­æ”¾...', 'success');
                console.log('åŠ¨ç”»æ•°æ®æ¥æ”¶æˆåŠŸ:', result.data);

                // æ’­æ”¾åŠ¨ç”»
                await playAnimationWithAudio(result.data, audioFile);
            } catch (error) {
                console.error('é”™è¯¯:', error);
                showStatus('é”™è¯¯: ' + error.message, 'error');
            } finally {
                startBtn.disabled = false;
                startBtn.innerHTML = 'å¼€å§‹ç”ŸæˆåŠ¨ç”»';
            }
        };

        // æ’­æ”¾åŠ¨ç”»å’ŒéŸ³é¢‘
        async function playAnimationWithAudio(animationData, audioFile) {
            // åˆ›å»ºéŸ³é¢‘å…ƒç´ 
            if (audioElement) {
                audioElement.pause();
            }
            
            audioElement = new Audio(URL.createObjectURL(audioFile));
            
            // å‡†å¤‡åŠ¨ç”»æ•°æ®
            const blendshapes = animationData.blendshapes || [];
            const duration = animationData.duration || 3.0;

            // æŒ‰æ—¶é—´æ’åº
            blendshapes.sort((a, b) => a.time - b.time);

            // æ’­æ”¾éŸ³é¢‘
            audioElement.play();

            const startTime = Date.now();
            currentAnimation = true;

            function updateAnimation() {
                const elapsed = (Date.now() - startTime) / 1000; // ç§’

                if (elapsed >= duration || !currentAnimation) {
                    // åŠ¨ç”»ç»“æŸ,é‡ç½®
                    resetHeadAnimation();
                    currentAnimation = null;
                    showStatus('åŠ¨ç”»æ’­æ”¾å®Œæˆ', 'success');
                    return;
                }

                // æ‰¾åˆ°å½“å‰æ—¶é—´å¯¹åº”çš„ blendshape å€¼
                const currentBlendshapes = blendshapes.filter(
                    bs => Math.abs(bs.time - elapsed) < 0.1
                );

                // åº”ç”¨ blendshapes
                applyBlendshapes(currentBlendshapes);

                requestAnimationFrame(updateAnimation);
            }

            updateAnimation();
        }

        // åº”ç”¨ blendshape åŠ¨ç”»
        function applyBlendshapes(blendshapes) {
            if (!head || !head.userData) {
                return; // å¦‚æœ head æˆ– userData ä¸å­˜åœ¨ï¼Œç›´æ¥è¿”å›
            }
            
            const { mouth, leftEye, rightEye, leftBrow, rightBrow } = head.userData;
            
            // ç¡®ä¿æ‰€æœ‰å¯¹è±¡éƒ½å­˜åœ¨
            if (!mouth || !leftEye || !rightEye || !leftBrow || !rightBrow) {
                console.warn('æŸäº›åŠ¨ç”»æ§åˆ¶å¯¹è±¡æœªæ‰¾åˆ°ï¼Œè·³è¿‡åŠ¨ç”»åº”ç”¨');
                return;
            }

            blendshapes.forEach(bs => {
                const { name, value } = bs;

                try {
                    switch(name) {
                        case 'jawOpen':
                            // å˜´å·´å¼€åˆ
                            const scale = 1 + value * 1.5;
                            if (mouth && mouth.scale) {
                                mouth.scale.set(scale, scale, 1);
                            }
                            break;
                        
                        case 'mouthSmile':
                            // å¾®ç¬‘
                            if (mouth && mouth.rotation) {
                                mouth.rotation.x = Math.PI - value * 0.3;
                            }
                            break;
                        
                        case 'eyeBlinkLeft':
                            // å·¦çœ¼çœ¨çœ¼
                            if (leftEye && leftEye.scale) {
                                leftEye.scale.y = 1 - value * 0.8;
                            }
                            break;
                        
                        case 'eyeBlinkRight':
                            // å³çœ¼çœ¨çœ¼
                            if (rightEye && rightEye.scale) {
                                rightEye.scale.y = 1 - value * 0.8;
                            }
                            break;
                        
                        case 'browInnerUp':
                            // çœ‰æ¯›ä¸Šæ‰¬
                            if (leftBrow && leftBrow.position) {
                                leftBrow.position.y = 0.5 + value * 0.1;
                            }
                            if (rightBrow && rightBrow.position) {
                                rightBrow.position.y = 0.5 + value * 0.1;
                            }
                            break;
                    }
                } catch (error) {
                    console.warn(`åº”ç”¨ blendshape ${name} æ—¶å‡ºé”™:`, error);
                }
            });

            // æ·»åŠ è½»å¾®çš„å¤´éƒ¨è¿åŠ¨
            if (head && head.rotation) {
                head.rotation.x = Math.sin(Date.now() * 0.001) * 0.05;
                head.rotation.z = Math.cos(Date.now() * 0.0015) * 0.03;
            }
        }

        // é‡ç½®åŠ¨ç”»
        function resetHeadAnimation() {
            if (!head || !head.userData) {
                return;
            }
            
            const { mouth, leftEye, rightEye, leftBrow, rightBrow } = head.userData;
            
            if (mouth) {
                if (mouth.scale) mouth.scale.set(1, 1, 1);
                if (mouth.rotation) mouth.rotation.x = Math.PI;
            }
            if (leftEye && leftEye.scale) leftEye.scale.set(1, 1, 1);
            if (rightEye && rightEye.scale) rightEye.scale.set(1, 1, 1);
            if (leftBrow && leftBrow.position) leftBrow.position.y = 0.5;
            if (rightBrow && rightBrow.position) rightBrow.position.y = 0.5;
            if (head.rotation) {
                head.rotation.x = 0;
                head.rotation.z = 0;
            }
        }

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        window.addEventListener('load', () => {
            initScene();
            
            // æµ‹è¯•åç«¯è¿æ¥
            fetch(`${API_BASE_URL}/api/health`)
                .then(res => res.json())
                .then(data => {
                    console.log('âœ… åç«¯æœåŠ¡è¿æ¥æˆåŠŸ:', data);
                })
                .catch(err => {
                    console.error('âŒ åç«¯æœåŠ¡è¿æ¥å¤±è´¥:', err);
                    showStatus('è­¦å‘Š: æ— æ³•è¿æ¥åˆ°åç«¯æœåŠ¡ (localhost:3000)', 'error');
                });
        });
    </script>
</body>
</html>

